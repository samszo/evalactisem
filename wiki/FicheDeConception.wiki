=I. Introduction=

"Le Social bookmarking (ou "Marque-page social", en français) est une façon pour les internautes de stocker, classer, chercher et partager leurs liens favoris." selon Wikipédia Rendu populaire par des sites tels que "Mister Wong" ou encore "del.icio.us", le social bookmarking permet aux internautes la sauvegarde de leurs bookmarks (signets, liens favoris) directement sur un site web public de "social bookmarking service".Les internautes gèrent leurs bookmarks grâce à des mots-clés (tags ou libellés) et peuvent partager, avec les autres utilisateurs.
Les internautes peuvent, aussi, effectuer des recherches parmi les bookmarks sociaux via les tags afin de trouver de nouveaux articles ou sites. Fréquemment, un "tags cloud" (nuage de tags) aide à la recherche.

 * Les intérêts des  du social bookmarking :
   # Le social bookmarking permet d'externaliser les bookmarks et de les centraliser sur un service accessible de n'importe où.
   # Les tags des ressources sont choisis par les internautes qui comprennent le contenu contrairement aux moteurs de recherche. Ceci fournit des étiquettes classées "sémantiquement".
   # Les internautes sauvegardent et partagent les ressources qu’ils jugent les plus utiles.
   # Généralement, les sites de Social bookmarking permettent de s’abonner à des flux RSS afin de s'informer des derniers favoris partagés,
   # et permettent, aussi, d'exporter / importer les favoris vers d'autres sites et votre navigateur.

 * Les inconvénients du Social Bookmarking sont :
   # Il n’existe pas de standard pour la structure des tags (ex. : majuscules, singulier   ou pluriel ...). Une ressource peut être mal étiquetée...
   # Les spammeurs indexent plusieurs fois la même page web en utilisant un grand nombre   d’étiquettes populaires...

C’est pour résoudre  le problème de la non standardisation de la structure des tags qu’on propose de traduire les tags avec le métalangage IEML  pour ajouter une couche informatique permettant un traitement automatique de la sémantique de ces tags. 

=II. Conception= 
==II.1  Présentation de Projet :== 
Dans le cadre du développement d’IEML (cf. http://www.ieml.org), une équipe de chercheurs se met en place pour mettre à la disposition du public des outils Open Source utiles pour l’organisation sémantique de l’information. 
En partenariat avec le laboratoire Paragraphe de l’université Paris 8, MUNDIGO propose de développer une application générique utilisant IEML pour donner une représentation sémantique d’un flux d’information. Dans cette première phase, un exemple fonctionnel utilisant l’API del.icio.us ( http://del.icio.us/help/api/ ) comme source d’un flux d’information sera traduit semi automatiquement en IEML pour en donner une représentation graphique et sémantique (SVG). 
 * Plusieurs objectifs sont fixés dans le cadre de ce projet :
   * Mettre en place une plateforme de développement Open Source
   * Développer des modules informatiques pour :
     # Gérer le flux provenant de l’API del.icio.us,
     # Traduire semi automatiquement un flux en IEML,
     # Représenter le parsing d’une expression IEML en graphique SVG dynamique,
   * Publier les développements sur une plateforme de publication de code.

Cet exemple permet de montrer concrètement comment IEML permet de mieux se repérer dans un l’espace sémantique issue d’une folksonomie del.icio.us.
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig1.PNG

===II.1.1  Acteurs du projet ===
 * Equipe de conception
   * Prof. Pierre Lévy, titulaire de la Chaire de Recherche du Canada en Intelligence Collective.
   * Samuel Szoniecky, ingénieur sémantique, co-fondateur de la société MUNDIGO
 * Equipe de réalisation
    * Samuel Szoniecky
    * Bourenane amel
==II.1.2  Définition de la cible ==
Ce projet est destiné aux utilisateurs du bookmark social del.icio.us, il leurs offre  une interface  utilisateur riche pour visualiser et traduire leurs tags. Les chercheurs intéressés par les applications du langage IEML  et plus généralement par le web sémantique, pourront trouver là, la première application qui utilise ce langage pour l’ajout d’une couche sémantique.

===II.2 État de l’art ===
L’ajout d’une couche sémantique au web vise à donner à une information un sens bien défini pour permettre aux ordinateurs et aux gens de travailler en coopération. Les outils qui permettent d’ajouter cette couche de sens sont :

 * XML (eXtended Mark-up Language), dérivé du langage SGML, qui permet de décrire de manière universelle la structure des données ;
 * RDF (Ressource Description Framework) qui permet de cataloguer les données du Web et le langage Sparkl qui permet d’interroger les ressources ainsi cataloguées ;
 * OWL (Ontology Web Language), qui permet de décrire les « ontologies » qui sont des réseaux sémantiques -le plus souvent des arbres ou des taxonomies -décrivant les relations entre concepts d’un domaine de connaissance

L’objectif initial de xml est de faciliter l'échange automatisé de contenus entre systèmes d'informations hétérogènes (interopérabilité) donc il donne une structure aux informations mais pas de sens. XML permet aux utilisateurs d'ajouter une structure arbitraire à leurs documents sans rien dire de la signification des structures.
L’inconvenant des ontologies est qu’elles sont écrites en langage naturelle. De fait, les ontologies considérées comme structures de relation ne sont pas automatiquement traductibles les unes avec les autres. OWL permet seulement l’exécution d’inférences automatiques au sein d’une même ontologie. La même remarque peut être faite au sujet de RDF, dont la lacune tient à la formulation en langue naturelle du contenu des documents.

Concernant la visualisation du flux de l’api del.icio.us, il existe plusieurs mashup qui proposent des représentations graphiques de ce flux. Voici quelques exemples qui nous semblent intéressants. 

===1. 6Pli===
Il propose trois types de graphes tous basés sur la métrique de similarité entre les tags.

===1.1   Elastic net 3D :===
Représente les tags et les bookmarks avec une animation 3D. Les tags sont des rectangles et les bookmarks sont des cercles. Deux cercles sont proche s’ils ont plus de tags on communs de même si un tag est souvent groupé avec d’autres tags il apparaît plus près a ce groupe.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig2.PNG

===1.2   Elastic net 2D :===
Le même principe que l’animation 3D la seule différence est quelle est une projection de l’animation 3D sur un plant plat.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig3.PNG

===1.3  Circles 2D:===
La vue cerculaire organisé les tags et les bookmarks auteur de leurs bundles (groupes  del.icio.us). Les points de départs sont aléatoires.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig4.PNG

===2.  Revealicious=== 
Composé de trois applets flash interactives :

===2.1 SpaceNav :===
Le principe de Space Nav est de représenter pour un tag sélectionné l’ensemble des tags relatifs, c’est à dire les tags qui ont été utilisés au moins une fois avec le tag sélectionné, et de permettre, une navigation de proche en proche”.
Pour ce faire, SpaceNav représente chaque tag par un point (en positionnant le curseur dessus, l’utilisateur peut avoir des informations plus précises, comme le nom du tag), entouré des tags qui lui sont directement connexes, les tags relatifs .en dessous de chaque point il y a un auréole: celle-ci indique le nombre d’entrées (de posts) qui ont été taggées avec le tag central. Plus l’auréole est grande, plus le tag a été utilisé.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig5.PNG

===2.2  TagsCloud:===
Affiche les tags ce forme du nuage. Les tags on des tailles et des couleurs différentes selon leurs fréquences d’utilisations (plus utilisé, couramment utilisé, peu utilisé).
La méthode de calcul pour déterminer l’appartenance à une catégorie est la suivante : la valeur moyenne du nombre de fois où un tag est utilisé dans un post comparée a une valeur min et une valeur max .

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig6.PNG

===2.3  Grouper:===
Permet a l’utilisateur d’organiser ses tags dans des groupes selon des critères qu il défini.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig7.PNG

On peut trouver d’autres exemples dans http://www.visualcomplexity.com ou dans 
http://www.programmableweb.com.

Bien que ces mashups dans des représentations graphiques des tags del.icio.us  et permettent de définir des relations entre des tags mais ces relations sont déterminées d’une manière statistiques ou manuelle (intervention de l’utilisateur), en effet elles partent de fait qu’un bookmark del.icio.us est composé d’un ensemble de tags, dont la plupart ont été utilisés en même temps. Chaque tag étant relié à d’autres tags, eux-mêmes reliés à d’autres tags, ce qui permet de parcourir l’ensemble des tags en évoluant de proche en proche. Et si un tag apparais fréquemment avec d’autres tags ils sont considérés proche sémantiquement. 

L’inconvenant de cette méthode est que si un bookmark contient des posts qui sont décrits par une seul tag ou par plusieurs tags qui ne se répète pas pour plusieurs raisons (l’utilisateur s’intéresse a des sujets vraies ou il utilise plus d’une langue pour tagger ces liens) on n’obtient pas un graphe connexe mais plusieurs graphes séparée parce qu il va y avoir des tags qui ne seront pas relies aux d’autres tags même s’il y a une relation sémantique entre eux et on ne pourra pas naviguer dans l’ensemble de bookmark.

 *L’avantage d’utiliser IEML  comme une couche sémantique dans evalactisem est qu’il va permettre de :

  * regrouper les tags par rapport à des concepts,
  * repérer automatiquement les relations entre les concepts,
  * faire des opérations ensemblistes sur les agrégations,
  * calculer l’adresse sémantique de chaque tag et ainsi obtenir une position unique  dans l’espace sémantique.
  * Cette classification des bookmarks donne une idée sur le type de sujets aux quels l’utilisateur s’intéresse et donc pouvoir l’orienté vers des sujets complémentaires ou de lui proposé des networks qui partagent les mêmes intérêts.
  * la traduction des tags avec un langage pivot comme l’IEML  permet de définir les relations entre les tags même s ils sont écrits dans des langues différentes. 
==III.  Service offerts== 
Le système récupère le flux de l’API del.icio.us ensuit il le traduit dans le langage IEML  pour ajouter une couche sémantique à ce flux. La traduction est  visualisée  par des camemberts. 

Les services offerts  sont :
====1. Récupération du flux====
L’application ce connecte à l’API del.icio.us après l’authentification de l’utilisateur pour la récupération du flux.

    * L’utilisateur peut choisir le type de flux qu il souhait récupéré :
    * Les tags de bookmark,
    * Les bundles ou groupes del.icio.us,
    * Tous les posts de bookmark,
    * Les posts récents,
    * Filtrer des posts par rapport à des urls, des tags ou des dates.
====2. Traduction du flux====
La traduction est semi-automatique. S’il existe une traduction unique du tag la traduction est sauvegardée dans la base de données, et dans le cas où il existe plusieurs traductions c’est l’utilisateur qui va choisir la traduction qui lui semble pertinente parmi les traductions proposées. Sil n’existe pas de traduction sauf que l’utilisateur va choisir la traduction a partir du dictionnaire IEML  on utilisant la boussole IEML .
===3. Visualisation du flux===
L’application permet aux utilisateurs la visualisation de leurs flux (flux traduit ou flux original). 
Le flux récupéré ainsi que le flux traduit est représenté ce forme de table ou de camembert. 
==VI.   Architecture Fonctionnelle==
Dans cette partie, on détaille la structure fonctionnelle de notre système.
===VI.1 Acteurs principaux et rôle ===

 * Les administrateurs de l’outil informatique
 * Ingénieur sémantique
 * Web master
 * Les utilisateurs de del.icio.us
===VI.2 Concepts===
L’ensemble des concepts utilisés dans ce projet sont définis par une ontologie IEML .
==V. Architecture Technique ==
===V.1 Généralité===
====V.1.1 Description matériel====
Le matériel ce compose de 

 * un serveur web
 * des ordinateurs clients équipés de navigateur Firefox.
===V.1.2 Description des composants logiciels===  
Composantes logicielles du serveur :
 * Une base MySql : http://dev.mysql.com/doc/ 
 * La librairie PHP version 5 : http://www.php.net/ 

Composantes logicielles du client
 * Firefox 3.0 (moteur Gecko  1.8.1 : http://xulfr.org/wiki/Gecko )
===V.1.3 Description des liens===
Les liens utilisés sont ceux utilisés pour le WEB : HTML, XML…
===V.1.4 Choix d’implémentation===
Les technologies utilisées dans Evalactisem sont :
====V.1.4.1  Xul :====
XUL (prononcez « zoul ») est le langage d'interface utilisateur de Mozilla basé sur XML permettant de développer des applications multiplate-formes riches en fonctionnalités et pouvant tourner connectée ou non à Interne.

Avantages :

 * Langage de balisage puissant basé sur les widgets,
 * Basé sur des standards existants (XML, DOM, CSS, Javascript) : XUL est un langage basé sur le standard XML 1.0 du W3C.Les applications écrites en XUL sont aussi basées sur d'autres standards du W3C tels que HTML 4.0; les Feuilles de Style en Cascade (CSS) 1 et 2; le modèle de document objet (DOM) ; JavaScript 1.5, SVG .
 * Portabilité de la plate-forme :XUL est conçu pour être indépendant de la plateforme, rendant ainsi les applications facilement portables à tous les systèmes d'exploitation sur lesquels Mozilla tourne.
 * Séparation de l'aspect et de la logique de l'application : XUL donne une séparation claire entre la définition de l'application et la logique de programmation ("contenu" constitué de XUL, XBL, SVG et JavaScript), la présentation (« skin » constitué de CSS et d'images), et les labels spécifiques au langage (« locale » constitué de DTDs).
 * Support plusieurs technologies introduites par Mozilla qui le complète pour développer des applications web multiplate-formes (XBL, Overlays, XPCOM/XPConnect, XPInstall).
====V.1.4.2 SVG (Scalable Vector Graphics) ====
Permet d'écrire des graphiques vectoriels 2D en XML.

Avantages:
 * Langage libre de droit (aucune licence demandée),
 * Étant issu du XML, il offre la possibilité d'utiliser tous les outils XML dont les parsers, les outils de transformations et les bases de données.
 * Langage supporté par les technologies d'Internet les plus communes (HTML, GIF, JPEG, PNG, SMIL, ASP, JSP, PHP, Javascript).

 * Intégration des trois types d'objets graphiques : Formes vectorielles, images, texte
 * Possibilité de zoomer et de retailler une zone de vision.
 * Compression possible d'un fichier SVG jusqu'a 95% (en utilisant lcompression gzip).
====V.1.4.3 IEML  (Information Economy Meta Language)====
 * Langue artificielle Conçue pour être simultanément manipulable de manière optimale par les ordinateurs.

 * Un système d’adressage des concepts indépendant des langues naturelles et traductible dans toutes les langues.
 * Un adressage des concepts transversal aux ontologies (classifications, terminologies, thésaurus...).
 * Un “langage régulier” (au sens mathématique).

En plus des ces technologies récentes evalactisem utilise 
  * Php ,
  * MySql,
  * Javascript,
  * CSS,
  * Xml,
==V.2.Schéma général & description des flux==

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig8.PNG

     ====Fig 4: Schéma général & description des flux====

L’architecture de EvalActisem est une architecture Client/Serveur. 

Coté client on trouve les modules suivant :
 * Interface IHM : composée d’interface utilisateur construit avec Xul qui permet à l’utilisateur d’accéder aux différents services proposé par EvalActiSem (récupération du flux, traduction et visualisation).
 * Modules javascripts permettant la communication entre l’interface utilisateur et le serveur (la création dynamique des arbres, la gestion de traduction, la création du graphique…) en utilisant des requêtes REST (http://fr.wikipedia.org/wiki/Representational_state_transfer) ainsi que la communication enter l’interface utilisateur et l’api GoogleDocs on utilisation des requêtes Json .
Coté serveur : 
 * Module base de données : pour le stockage des flux des utilisateurs, les traductions, l’activité de l’utilisateur,
 * Modules PHP pour la récupération du flux, la création des graphes et des arbres pour la visualisation du flux.

Les flux d’information  gérés par EvalActiSem sont de trois ordres :
 # Lecture de la base de données pour générer le flux  IEML .
 # Utilisation de protocole HTTP pour récupérer le flux de l’API del.icio.us grâce à des fonctions PHP qui utilise la bibliothèque Curl.
 # Des requêtes Ajax pour la communication ente l’interface de gestion et les modules PHP et aussi pour la communication entre le serveur et l’api GoogleDocs.  
==V.2.1 Base de données pour EvalActiSem==
La base de données est modélisée suivant un schéma relationnel pour optimiser la gestion des flux. 
Ce modèle est conçu pour être le plus générique possible afin de facilement l’utiliser pour de nouvelles ontologies IEML  et d’autres système d’information.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig9.PNG

         ====Fig 5: Modele de base de données====

====Table ieml_onto====
Cette table est utilisée pour stocker le dictionnaire IEML.

|| *Champ*     || *Type*      || *Description*                                         ||
|| ieml_id     || int(11)     || Clef primaire auto_increment identifiant de la couche ||
|| ieml_code   || Text        || Expression IEML  exprimée en langage IEML             ||
|| ieml_desc   ||varchar(255) || Descriptif exprimé en langage naturel                 ||
|| ieml_niveau ||int(11)      || Niveau de l’expression IEML  dans l’arbre des couches ||
|| ieml_parent ||int(11)      || Identifiant de la couche parente                      ||
  
Nous proposons de limiter le descriptif de l’expression IEML  (champ ieml_desc) à 255 caractères.

====Table ieml_onto_flux====
Cette table est utilisée pour stocker le flux récupéré.

|| *Champ*           || *Type*      || *Description*                                         ||
|| onto_flux_id      || int(11)     || Clef primaire auto_increment identifiant de la connexion||
|| onto_flux_code    || varchar(255)|| Nom du Tags IEML          ||
|| onto_flux_desc    ||varchar(255) || Tags ou bundles   naturel ||
||onto_flux_niveau   ||int(11)      || 1 pour les Tags et 0 pour les Bundles ||
|| onto_flux_parents ||int(11)      || Liste de Tags parents séparer par des points virgules ||

====Table ieml_trad====
Cette table est utilisée pour stocker les traductions du Flux en expression IEML .

|| *Champ*      || *Type*      || *Description*                                         ||
|| ieml_id      || int(11)     || Identifiant de la table ieml_onto                     ||
|| onto_flux_id || int(11)     || Identifiant du flux                                   ||
|| trad_date    ||Date         || Date d’ajout de traduction                            ||

====Table ieml_uti_onto====
Cette table est utilisée  pour faire la jointure entre l’utilisateur et ces traductions. 

|| *Champ*      || *Type*      || *Description*                                         ||
|| uti_id       || int(11)     || Identifiant de l’utilisateur                          ||
|| ieml_onto_id || int(11)     || Identifiant de la table onto                          ||

====Table ieml_acti====
Cette table est utilisée pour stocker les actions du l’utilisateur à prendre en compte pour l’évaluation de l’activité 

|| *Champ*      || *Type*      || *Description*                                         ||
|| acti_id      || int(11)     || Identifiant de la table ieml_acti                     ||
|| acti_code    || text        || Chaîne de caractère exprimé avec le langage IEML   suivant la formule suivante : Source = nom de la page et identifiant de l’élément XUL a l’origine de l’activité.Destination = nom de la page et identifiant de l’élément XUL affichant le résultat de l’activité. Traduction = nom de la méthode utilisée.           ||
|| acti_desc    ||varchar(255)    || Descriptif exprimé en langag naturel               ||

====Table ieml_flux====
Cette table est utilisée pour stocker les flux IEML  produit par l’activité de l’utilisateur.

|| *Champ*     || *Type*      || *Description*                                         ||
|| flux_id     || int(11)     || Identifiant de la table ieml_flux                     ||
|| acti_id     || int(11)     || Identifiant de la table ieml_acti                     ||
|| flux_ieml   || Text        || Chaîne de caractère formaté avec le langage star sous la forme :Source = l’identifiant de l’utilisateur effectuant l’action : tu-tu-.we-b-.tu-nu-du-.[personnes,id,-]:(nombre, système d’information [nom de la table, nom du champ, -] unique)Destination = la phrase IEML correspondant au contexte sémantique de l’action Translation = la phrase IEML  correspondant au contexte sémantique du processus (navigation) ayant amené l’action. Cette expression IEML  sera construite dynamiquement par les actions de l’utilisateur.  ||
|| flux_date    ||   Date     || Date de création du flux                              ||

Il n’y a pas de taille limite pour le flux.
Chaque flux est associé à une action sur le logiciel EvalActiSem.

===V.2.2. Communication Php/MySql===
MySql permet la communication entre les fonctions PHP et la base de données. Le flux  récupéré est stocké dans la base de données dans la table del.icio.us ainsi que la traduction du flux.
===V.2.3. Communication serveur PHP/API del.icio.us===
Les classes PHP communiquent avec l’API del.icio.us on utilisant le protocole HTTP, la bibliothèque Curl de PHP permet de se connecter, de communique avec différents serveurs, grâce à de nombreux protocoles .libcurl supporte actuellement les protocoles suivants : HTTP, HTTPS, FTP, gopher, telnet, dict, file, et LDAP. libcurl supporte aussi les certificats HTTPS, les POST HTTP, PUT http [3]. 

La réponse de API del.icio.us est ce forme d’XML, la classe php le récupère, le parse et stocke le résultat dans la base de données.    
===V.2.4. Communication serveur PHP/StartParser  IEML ===
La communication entre le serveur PHP et le StartParser IEML [4] s’effectuer a l’aide des requêtes Curl. 
===V.2.5. Communication serveur  interface de gestion Xul/Serveur PHP===
L’interface de gestion communique avec le serveur PHP par des fonctions java script, une fois l’utilisateur a saisir sont login, son password et a choisi le type de visualisation qu’il souhait l’interface envoie les paramètres  de connexion a la fonction php-delicious qui se charge de la connexion avec l’API del.icio.us ainsi que de la récupération du résultat.
===V.2.6. Communication Serveur /API GoogleDocs===
Le serveur communique avec  l’api GoogleDocs par l’intermédiaire des requêtes Jason. Il envois a l’api GoogleDocs une requête en précisant le type de visualisation qu’il veut récupérer et la clé du document a récupérer. L’api répond on envoyant la réponse sous le format Jason.    
==VI. Description  des l’interfaces==
===VI.1 Interfaces logiciels===
====VI.1.1 Les objets PHP ====
Ces objets sont développés en PHP 5.
====VI.1.1.1 PhpDelicious ====
Cet objet permet de ce connecter a l’API del.icio.us et de traiter les résultats.

|| *Propriétés*                                                                        ||
|| *Nom*       || *Type*               || *Description*                                ||
|| sUsername   || Chaîne de caractères || Login  del.icio .us                          ||
|| sPassword   || Chaîne de caractères || Mot de passe del.icio.us IEML                ||
|| iCacheTime  || int                  || La durée en seconde pour mettre en cache les données récupérées                    ||
|| oXmlParder  || Objet                || Objet permettant de traiter les données del.icio.us retournées                     ||
|| bFirstchange|| Booléen              ||                                              ||
|| iLastError  || int                  ||  Type d’erreur qui prouve se produire de la connexion au serveur del.icio.us       ||


|| *Méthodes*                                                                          ||
|| *Nom*        || *IN*                          || *OUT*             ||*Description*  ||
|| PhpDelicious ||sUsername,sPassword,iCacheTime || Objet del.icio.us || Méthode de création de l’objet        ||
||HttpRequest   || sCmd                          ||                   ||Requête curl qui sera envoyée    ||
|| GetLastUpdate||         ||Date                ||Retourne la date de la dernière mise à jour            ||
||GetAllTags    ||         || Tags               ||Retourne une liste de Tags          ||
||RenameTag     ||sOld,sNew|| Tags               ||Renomme une Tag                     ||
||GetRecentPosts||sDate,iCount|| Tags            ||Retourne une liste de Posts filtrer en fonction de Tags, nombre maximum de Posts retourner est 15                             ||
||GetAllPosts   ||sTag     || Post               ||Retourne une liste de tous les Posts filtrer en fonction de Tags.                     ||
||GetDates      ||sUrl,sDescription,sNotes,aTags,sDate,bReplace                        || True ou flase   ||Ajoute un Posts              ||
||DeletePost    ||sUrl     ||                     ||Supprime un Post                   ||
||GetAllBundles ||         ||                     ||Récupère  tous les groupes de tags del.icio.us     ||
||DeleteBundle  ||sName    ||                     ||Supprime un bondles                ||
||GetPosts      ||sTag,sDate,sUrl                 || Post               ||Retourne une liste de Posts filtrer en fonction de Tags , Date ou Url||

====VI.1.1.3.2 Acti====
Cet objet hérite de l’objet EvalActiSem. Il permet de gérer les données relatives à l’activité des utilisateurs.

|| *Propriétés*                                                                              ||
|| *Nom*       || *Type*               || *Description*                                      ||
|| Id          || Entier               || Identifiant de l’activité                          ||
|| Type        || Chaîne de caractères ||Type d’activité : cf. doc 1 et 5                    ||
|| Sem         || Objet Sem            || Objet permettant de gérer les données sémantiques  ||

|| *Méthodes*                                                                                      ||
|| *Nom*        || *IN*                            || *OUT*             ||*Description*            ||
|| __construct  || Type     || Objet Acti          || Méthode de création de l’objet               ||
|| GetSem       || Date     || Tableau d’objet Sem ||Récupère la collection des objets Sem         ||
|| SetActi      ||          ||                     ||Enregistre l’activité dans la base de données ||

====VI.1.1.3.3 Sem====
Cet objet contient les méthodes pour la construction du dictionnaire, la sauvegarde des traductions, la construction des camemberts et le parse des expressions IEML. 

|| *Propriétés*                                                                              ||
|| *Nom*       || *Type*               || *Description*                                      ||
|| Id          || Entier               || Identifiant de la donnée sémantique                ||
|| Flux        || Chaîne de caractères ||Flux IEML  en langage star                          ||
|| Date        || Date                 || Date du flux                                       ||

|| *Méthodes*                                                                                                                     ||
|| *Nom*          || *IN*                           || *OUT*               ||*Description*                                        ||
|| __construct    || Date                           || Objet Acti          || Méthode de création de l’objet                      ||
|| GetFlux        ||                                || Chaîne de caractères||Récupère le flux dans la base de données             ||
|| InsertIemlOnto || IEML Code,IEML Lib,IEML Prent  || Chaîne de caractères||Construction du dictionnaire IEML                    ||
|| RecupOntoTrad  ||                                || Chaîne de caractères|| Récupère les traductions sauvegardées dans la BDD   ||
|| Parse          || IEML Code                      || Flux Xml            ||Construction du dictionnaire IEML                    ||
|| GetSvgPie      || IEML Code                      || SVG                 ||Création de camembert pour l’expression IEML         ||
|| SetFlux        || Chaîne de caractères           || Flux Xml            ||Enregistre le flux dans la base de données           ||

====VI.1.1.3.4 Xul ====
Cet objet continents des méthodes pour la création des composants Xul : Tree , ListBox, Panel . 

|| *Propriétés*                                                                              ||
|| *Nom*       || *Type*               || *Description*                                      ||
|| Id          || Entier               || Identifiant de la donnée sémantique                ||
|| site        || Objet                ||Objet pour la connexion a la base de données        ||
|| XmlParam    || Objet                || Date du flux                                       ||

|| *Méthodes*                                                                                                                     ||
|| *Nom*          || *IN*                           || *OUT*               ||*Description*                                        ||
|| __construct    || Date                           || Objet Xul           || Méthode de création de l’objet                      ||
|| GetTreeTrad    || Flux, Trad descp, primary, bdd || XUL                  ||Crée le tree des traductions                         ||
|| TableFlux      || sDescp, sUrl, sDate, sNote     || XUL                 ||Crée la table de flux                                ||

====VI.1.1.5 SVG====
Cette collection d’objets permet de générer des graphiques SVG, cf. doc en ligne
===VI.1.2. Java script===
Afin de minimiser l’impact sur les pages existantes, le seul objet java script utilisé est XMLHttpRequest. Il permet d’envoyer des requêtes WEB de façon transparente pour l’utilisateur.
===VI.1.3. XUL===
Les interfaces de gestion sont développées avec XUL et plus particulièrement en utilisant les objets suivants :
 * Treeview
 * Menu
 * Splitter
Le cas échéant il sera développé des « bindings » : objets XUL étendus pour des besoins spécifiques.
==VII.Charte graphique ==
Dans ce qui nous allons décrire la charte graphique retenue pour ce projet :
===VII.1 Répartitions des différents espaces d'information à l'écran===

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig10.PNG

     === Fig 6 : Gabarit de l’application====

Le style  utilisé pour les différentes fenêtres de l’application et le style par défaut  appliqué par  Mozilla  pour les fenêtres XUL. Tous les composants de la  fenêtre hériteront de ce style. 

 * Couleur de fond : gris,
 * Texte : Arial, Taille  12,
 
La fenêtre principale et divisée en trois parties séparée par un splitter ce qui permet de redimensionnées les boites contigues:
 
 * *La partie* gauche  est réservée aux différents boutons et menus déroulants permettant l’accès  aux services proposées par l’application. 
 * *La partie* centrale  est dédie a la visualisation des données. Les données seront  visualisées se forme d’arbres hiérarchiques ou des tableaux  on utilisant les composants tree et listbox. Le contenu de cette partie change en fonction de service en cours d’exécution. Dans le cas d’une visualisation du flux del.ici.ous elle est composée d’un seul listbox  ou d’un tree, dans le cas d’une traduction elle sera divisée verticalement en deux parties : 

   * En  haut des labels pour afficher les mots IEML , les  descriptifs IEML  et les tags que l’utilisateur a sélectionner a partir des trees.
   * En bas un groupe de panels, les trois premiers panels contient des trees tandis que le quatrième panel contient un groupe de panels organisés verticalement. 
 * La partie droite contient des graphiques, ils sont affichés en haut a gauche. Hauteur 400 px, largeur 300px.
==VII.2 Couleurs utilisées==
 *Bouton : titre (noire), fond (gris clair);
 * Fenêtre (gris clair) ;
 * Tableau, arbre : entête (gris clair), fond (blanc) ; 
 * Graphique : fond (jaune), éléments (vert, rouge, bleu, jaune, orange, violet,  fuchsia, teal). 
===VII.3 Eléments de style ===	
 * labels : size : 12px, font-family : Arial.
 * Contenu des tableaux et des arbres  size : 12px, font-family : Arial.
 * Titre des graphiques : size : 12px, font-family : Arial.

==VII.4 les graphiques==
Il y a deux types de graphiques réaliser avec SVG :
 * Camemberts : pour la visualisation de flux originaux  et les flux traduits. 
 * IEML Boussole : un ensemble de  formes géographiques (rectangles, hexagones) utilisé pour modélisée les couches IEML .
==VII .Charte éditorial==  
Dans cette charte on définie les grandes lignes éditorial de notre projet.
 * Les informations manipulées dans l’application sont les tags récupérer a partir de compte del.icio.us  ainsi que les traductions de c est dernière en langage IEML .  
 * Le système est édité en français (les menus, les noms des bottons, etc...) mais les données récupérées peuvent être de n’importe quelle longue ça dépendra de la langue que l’utilisateur utilise pour tagger ces pages).
 * Le langage utilisé pour la traduction du flux est le langage IEML  (un métalangage). 
==VIII. Charte Fonctionnelle== 
La charte fonctionnelle décrie l’architecteur hypertextuel de l’application ainsi que son fonctionnement. 
===VIII.1 Architecture hypertextuelle ===

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig11.PNG

              ===Fig 7 : Architecture hypertextuelle===

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig12.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig13.PNG

              
			  ===Fig8 : la fenêtre principale de l’application===

*-1- Récupération du flux *: dans cette partie l’utilisateur peut choisir le type de requête il veut faire ( le type de flux a récupérer). Il y a cinq types de requête :
 * Afficher tous les Tags : Afficher tous les tags qui sont dans le bookmark de l’utilisateur (compte del.icio.us).
 * Afficher les posts récents : Afficher les derniers posts que l’utilisateur a posté. L’utilisateur peut filtré les posts par rapport a un tag (afficher les posts récents  tagé  avec un tag donnée). comme il précis le nombre de posts affichés on renseignant le champ count.
 
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig14.PNG

               ===Fig 9 : Interface pour le choix des requêtes del.icio.us===

 * Afficher le post : Afficher les posts filtrés par rapport à un tag, une date  ou une url (effectue une recherche par tag, date ou url).
 * Afficher tous les posts : Affiche tous les posts sauvegarder dans le bookmark.
 * Afficher tous les bundles : Afficher les groupes de tags et les tags qui les composent. 

 Après le choix de la requête l’utilisateur doit click sur le bouton Afficher les données pour visualisre le flux récupérer.

 http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig15.PNG
 
              ===Fig 10 : Table de flux===
			  

 http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig16.PNG
 
             ===Fig 11 : Table du flux pour les requête de types posts===
			 
L’utilisateur peut accéder aux sites qu’il a bookmarker on cliquant sur la ligne correspondant au site dans la table.    

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig17.PNG

Les données seront représentées se forme de camembert. L’utilisateur peut choisir entre la représentation des tags en fonction de leurs nombres d’apparition  dans le bookmarke( le nombre de posts taggé avec le tag) ou les bundles en fonction des tags qu ils composent.  

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig18.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig19.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig20.PNG

Lorsque l’utilisateur click sur le bouton traduction il accède à la page traduction Fig 

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig21.PNG

La fenêtre de traduction est composée de trois parties : 

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig22.PNG

Dans cette partie, on a un ensemble de panels, les trois premiers représentent des tables de flux (flux original et traduit).
   * Dans le premier panel (_Tags Traduits_)  on a un arbre qui contient les tags  possédants une traduction unique  dans le langage IEML  (traduction automatique) ou les tags qui on étés traduits par l’utilisateur avec leurs traductions IEML  et le descriptif IEML  associé. 
   
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig23.PNG

  * Dans le deuxième panel (_Tags avec plusieurs traductions_) les tags ont plusieurs traductions possibles donc ils ne peuvent pas être traduits automatiquement.  C’est à l’utilisateur de choisir la traduction qui lui semble pertinente. Pour cela, il sélectionne la traduction à partir de l’arbre et il clique sur le bouton  _Ajouter_. Le tag traduit sera supprimé de cet arbre et ajouté à l’arbre qui est dans le panel Tags Traduits,  il sera  affiché avec une couleur vert pour signifier que c’est l’utilisateur qu il l’a ajouté.
  *	Dans le troisième (_Tags sans traductions_) panel, il y a les tags qui n’ont pas de traduction en IEML. Dans ce cas c est à l’utilisateur de choisir la traduction à partir du dictionnaire qui se trouve dans le quatrième panel (_dictionnaire et cycle_) ou en utilisant la boussole et les cycles.
  *	Le dernier panel (_Dictionnaire et cycle_) contient un ensemble de panels :
		* Un panel dictionnaire contient le dictionnaire IEML . Pour ajouter une traduction en utilisant le dictionnaire, l’utilisateur doit sélectionner le tag qu il veut traduire dans le panel des _Tags sans traductions_, ensuite il choisi la traduction dans le dictionnaire et il clic sur le bouton _Ajouter_.
	    * Plusieurs panels cycle, chaque panel représente un cycle IEML  . Ces cycles seront utilisés pour la traduction des tags qui n’ont pas étés traduits automatiquement.  

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig24.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig25.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig26.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig27.PNG

Dans cette partie, on affiche les différents graphiques liées a la traduction .Il y a deux types de graphiques :

    # Camembert,
    # Boussole IEML .
	
 * *Camembert* :   l’utilisateur peut visualiser les traductions on fonction des primitives  ou des events  qui composent l’expression IEML choisi. Pour cela il sélectionne les traductions qu’il veut visualiser à partir de l’arbre de _Tags Traduits_. Ensuite, il fait un clic droit, un menu s’affiche et il sélectionne  le type de présentation qu il souhaite. 
 
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig28.PNG

 * *Boussole IEML* : 
	La boussole IEML  est un outil qui  permet à  l’utilisateur de choisir une traduction  de manière graphique et interactive. Les branches extérieures (losange) représentent les couches IEML  (pour l’instant il n’y a que deux couches, celles des primitives et des événements) tandis que l’hexagone central représente les différents éléments d’une couche. 
Cet hexagone est constitue de deux couches. La première représente les pôles  : 
       * pragmatique O ou sémantique M pour les primitives ; 
       * énergies OO, actes OM, mutations MO, entités MM, OE ou ME pour les événements. La deuxième couche modélise les éléments de chaque pôle. 

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig29.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig30.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig31.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig32.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig33.PNG

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig34.PNG

-2- Bouton qui permet d’afficher des cercles sur la boussole, lorsque l’utilisateur clic sur un cercle il peut récupérer les coordonnées de ce point et construire une représentation graphique de sa navigation sur la boussole. Si la couleur du bouton est rouge il est désactivé ; si elle est verte il est activé.  

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig35.PNG

-3-  Bouton pour construire une représentation graphique de la traduction. La différence entre cette représentation et celle fournit par le bouton points est qu’avec cette représentation, on crée un pavé à chaque  clic et non pas un point. Si la couleur de bouton est verte il est activé, si elle est rouge il est désactivé.     

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig36.PNG

-4-Bouton pour la suppression du compte .s il l’utilisateur clic sur ce bouton son compte sera supprimer : son flux ainsi que ses traduction. 

==VI. Scénario d’utilisations==
===VI.1  Diagramme des cas d’utilisation===

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig37.PNG

====1.Récupération du flux :====

*Précondition *:
 * L’application doit être connectée à Internet pour qu’elle puisse communiquer avec l’api del.icio.us. 
 * L’utilisateur doit posséder un compte  del.icio.us.    
 
*Début* : 
La récupération du flux commence lorsque l’utilisateur choisi le type de requête qu’il veut exécuter (type de données à récupérer) et la validation de son choix en cliquant sur la bouton _Affiche Flux_.

*Fin *:
Lorsque l’api delicious répond à la requête envoyée par l’application. 

*Postcondition* :
Si la récupération du flux est terminée avec succès. Le flux sera sauvegardé dans une  base de données ainsi que dans un fichier xml et il sera visualisé avec une table et un camembert.  

*Déroulement normal* :
 #  l’utilisateur saisie son login et son  mot de passe del.icio.us.
 #	il choisit le  type de requête qu il veut effectuer (_le type du flux_).
 #	il choisit le type de graphique.
 #	il clic sur le bouton _Afficher les données_.
 #	l’application envoie une requête à l’API del.icio.us.
 #	si le login et le mot de passe saisie sont corrects l’API delicious envoie le flux à l’application.
 #	l’application compare le flux récupéré avec le flux sauvegardé.
 #	l’application créer les représentations et les affiches.

*Variantes* :
 * login ou mot de passe incorrects : si le login ou le mot de passe saisie par l’utilisateur sont incorrects un message d’erreur est affiché, l’utilisateur doit saisir le login et le mot de passe de  nouveau. 
 * Problème de connexion : si le système n’arrive pas à se connecter à l’API del.icio.us, un message d’erreur s’affiche. L’utilisateur doit vérifier qu’il est connecté à Internet. 
 
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig38.PNG
 
=== 2. Traduction du flux :===
*Précondition*:
Il faut y avoir un flux  déjà récupéré et stocké dans la base de données.
	
*Début* :
L’utilisateur clic sur le bouton Traduction.

*Fin* : 
L’utilisateur revient à l’interface principale. 

*Postcondition* :
Des mises à jour des tables onto_trad et ieml_onto_uti sont effectuées après que l’utilisateur effectue une nouvelle traduction. 

*Déroulement* :
 # lorsque l’utilisateur clic sur le bouton _Traduction_ l’application consulte le dictionnaire pour traduire le flux.
 #	si  elle trouve des traductions, elle associe au tag  le  code IEML  ainsi que son descriptif et elle les affiche dans la table _Tags traduits_. 
 #	si à un tag correspond plusieurs traductions, l’utilisateur choisi la traduction qui lui semble pertinente en cliquant sur la traduction voulu dans la table _Tag avec plusieurs traduction_ ensuite il clic sur la bouton _Ajouter_.
 #	dans le cas où il n’existe pas de traduction correspondante à un tag. L’utilisateur a deux moyens pour traduire le tag :
    * le dictionnaire IEML , dans ce cas il clic sur le tag qu’il veut traduire dans la table _Tags sans traduction_ ensuit sur la traduction IEML  dans le dictionnaire  et enfin il valide son choix en cliquant sur le bouton _Ajouter_.
    * La boussole IEML  et les tables des cycles: l’utilisateur peut utiliser la boussole pour traduire un tag. Pour cela, il choisi la couche à partie de laquelle il va sélectionner la traduction (primitives, éventements, relation,…) ensuite il choisi le pôle (pragmatique,  sémantique, énergie…) et enfin la traduction. A chaque fois que l’utilisateur clic sur la boussole les tables des cycles changes pour afficher que les mots correspondant  aux choix de l’utilisateur pour lui faciliter la traduction.

*Invariants* :

 * lors de l’étape 1 si aucun mot ni sélection un message s’affiche invitant l’utilisateur a sélectionné une traduction.
	
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig39.PNG

===3. Représentation graphique :=== 
*Précondition* 

Il faut qu’il existe une sauvegarde du flux récupéré dans un fichier Xml ainsi qu’une traduction en IEML  de ce flux.  

*Début*

L’utilisateur clic sur le bouton Afficher le graphique où il sélectionne une représentation dans le menu de l’arbre Tags Traduits.

*Fin* 

La construction de la représentation graphique à partir des expressions IEML  parser ou du flux original (flux non traduit).

*Postecondition*

Si l’expression IEML  est valide un flux xml est retourné par le StarPaser , ce flux contient les différents niveaux IEML  qui constituent cette expression.

*Déroulement* 
 #	lorsque l’utilisateur clic sur le bouton Graphique, le système crée une expression IEML  selon une syntaxe spécifique.
 #	le système envoie l’expression IEML  au parser IEML  pour que ce dernier la parse.
 #	à partir de réponse fournie par le parser IEML, le système crée la représentation graphique et l’affiche 

*Variante*

Si l’expression IEML  ni pas valide, un message d’erreur est affiché.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig40.PNG




 








                