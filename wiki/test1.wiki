=I. Introduction=

"Le Social bookmarking (ou "Marque-page social", en français) est une façon pour les internautes de stocker, classer, chercher et partager leurs liens favoris." selon Wikipédia Rendu populaire par des sites tels que "Mister Wong" ou encore "del.icio.us", le social bookmarking permet aux internautes la sauvegarde de leurs bookmarks (signets, liens favoris) directement sur un site web public de "social bookmarking service".Les internautes gèrent leurs bookmarks grâce à des mots-clés (tags ou libellés) et peuvent partager, avec les autres utilisateurs.
Les internautes peuvent, aussi, effectuer des recherches parmi les bookmarks sociaux via les tags afin de trouver de nouveaux articles ou sites. Fréquemment, un "tags cloud" (nuage de tags) aide à la recherche.

 * Les intérêts des  du social bookmarking :
   # Le social bookmarking permet d'externaliser les bookmarks et de les centraliser sur un service accessible de n'importe où.
   # Les tags des ressources sont choisis par les internautes qui comprennent le contenu contrairement aux moteurs de recherche. Ceci fournit des étiquettes classées "sémantiquement".
   # Les internautes sauvegardent et partagent les ressources qu’ils jugent les plus utiles.
   # Généralement, les sites de Social bookmarking permettent de s’abonner à des flux RSS afin de s'informer des derniers favoris partagés,
   # et permettent, aussi, d'exporter / importer les favoris vers d'autres sites et votre navigateur.

 * Les inconvénients du Social Bookmarking sont :
   # Il n’existe pas de standard pour la structure des tags (ex. : majuscules, singulier   ou pluriel ...). Une ressource peut être mal étiquetée...
   # Les spammeurs indexent plusieurs fois la même page web en utilisant un grand nombre   d’étiquettes populaires...

C’est pour résoudre  le problème de la non standardisation de la structure des tags qu’on propose de traduire les tags avec le métalangage IEML  pour ajouter une couche informatique permettant un traitement automatique de la sémantique de ces tags. 

=II. Conception= 
==II.1  Présentation de Projet :== 
Dans le cadre du développement d’IEML (cf. http://www.ieml.org), une équipe de chercheurs se met en place pour mettre à la disposition du public des outils Open Source utiles pour l’organisation sémantique de l’information. 
En partenariat avec le laboratoire Paragraphe de l’université Paris 8, MUNDIGO propose de développer une application générique utilisant IEML pour donner une représentation sémantique d’un flux d’information. Dans cette première phase, un exemple fonctionnel utilisant l’API del.icio.us ( http://del.icio.us/help/api/ ) comme source d’un flux d’information sera traduit semi automatiquement en IEML pour en donner une représentation graphique et sémantique (SVG). 
 * Plusieurs objectifs sont fixés dans le cadre de ce projet :
   * Mettre en place une plateforme de développement Open Source
   * Développer des modules informatiques pour :
     # Gérer le flux provenant de l’API del.icio.us,
     # Traduire semi automatiquement un flux en IEML,
     # Représenter le parsing d’une expression IEML en graphique SVG dynamique,
   * Publier les développements sur une plateforme de publication de code.

Cet exemple permet de montrer concrètement comment IEML permet de mieux se repérer dans un l’espace sémantique issue d’une folksonomie del.icio.us.
http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig1.PNG

===II.1.1  Acteurs du projet ===
 * Equipe de conception
   * Prof. Pierre Lévy, titulaire de la Chaire de Recherche du Canada en Intelligence Collective.
   * Samuel Szoniecky, ingénieur sémantique, co-fondateur de la société MUNDIGO
 * Equipe de réalisation
    * Samuel Szoniecky
    * Bourenane amel
==II.1.2  Définition de la cible ==
Ce projet est destiné aux utilisateurs du bookmark social del.icio.us, il leurs offre  une interface  utilisateur riche pour visualiser et traduire leurs tags. Les chercheurs intéressés par les applications du langage IEML  et plus généralement par le web sémantique, pourront trouver là, la première application qui utilise ce langage pour l’ajout d’une couche sémantique.

===II.2 État de l’art ===
L’ajout d’une couche sémantique au web vise à donner à une information un sens bien défini pour permettre aux ordinateurs et aux gens de travailler en coopération. Les outils qui permettent d’ajouter cette couche de sens sont :

 * XML (eXtended Mark-up Language), dérivé du langage SGML, qui permet de décrire de manière universelle la structure des données ;
 * RDF (Ressource Description Framework) qui permet de cataloguer les données du Web et le langage Sparkl qui permet d’interroger les ressources ainsi cataloguées ;
 * OWL (Ontology Web Language), qui permet de décrire les « ontologies » qui sont des réseaux sémantiques -le plus souvent des arbres ou des taxonomies -décrivant les relations entre concepts d’un domaine de connaissance

L’objectif initial de xml est de faciliter l'échange automatisé de contenus entre systèmes d'informations hétérogènes (interopérabilité) donc il donne une structure aux informations mais pas de sens. XML permet aux utilisateurs d'ajouter une structure arbitraire à leurs documents sans rien dire de la signification des structures.
L’inconvenant des ontologies est qu’elles sont écrites en langage naturelle. De fait, les ontologies considérées comme structures de relation ne sont pas automatiquement traductibles les unes avec les autres. OWL permet seulement l’exécution d’inférences automatiques au sein d’une même ontologie. La même remarque peut être faite au sujet de RDF, dont la lacune tient à la formulation en langue naturelle du contenu des documents.

Concernant la visualisation du flux de l’api del.icio.us, il existe plusieurs mashup qui proposent des représentations graphiques de ce flux. Voici quelques exemples qui nous semblent intéressants. 

===1. 6Pli===
Il propose trois types de graphes tous basés sur la métrique de similarité entre les tags.

===1.1   Elastic net 3D :===
Représente les tags et les bookmarks avec une animation 3D. Les tags sont des rectangles et les bookmarks sont des cercles. Deux cercles sont proche s’ils ont plus de tags on communs de même si un tag est souvent groupé avec d’autres tags il apparaît plus près a ce groupe.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig2.PNG

===1.2   Elastic net 2D :===
Le même principe que l’animation 3D la seule différence est quelle est une projection de l’animation 3D sur un plant plat.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig3.PNG

===1.3  Circles 2D:===
La vue cerculaire organisé les tags et les bookmarks auteur de leurs bundles (groupes  del.icio.us). Les points de départs sont aléatoires.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig4.PNG

===2.  Revealicious=== 
Composé de trois applets flash interactives :

===2.1 SpaceNav :===
Le principe de Space Nav est de représenter pour un tag sélectionné l’ensemble des tags relatifs, c’est à dire les tags qui ont été utilisés au moins une fois avec le tag sélectionné, et de permettre, une navigation de proche en proche”.
Pour ce faire, SpaceNav représente chaque tag par un point (en positionnant le curseur dessus, l’utilisateur peut avoir des informations plus précises, comme le nom du tag), entouré des tags qui lui sont directement connexes, les tags relatifs .en dessous de chaque point il y a un auréole: celle-ci indique le nombre d’entrées (de posts) qui ont été taggées avec le tag central. Plus l’auréole est grande, plus le tag a été utilisé.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig5.PNG

===2.2  TagsCloud:===
Affiche les tags ce forme du nuage. Les tags on des tailles et des couleurs différentes selon leurs fréquences d’utilisations (plus utilisé, couramment utilisé, peu utilisé).
La méthode de calcul pour déterminer l’appartenance à une catégorie est la suivante : la valeur moyenne du nombre de fois où un tag est utilisé dans un post comparée a une valeur min et une valeur max .

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig6.PNG

===2.3  Grouper:===
Permet a l’utilisateur d’organiser ses tags dans des groupes selon des critères qu il défini.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig7.PNG

On peut trouver d’autres exemples dans http://www.visualcomplexity.com ou dans 
http://www.programmableweb.com.

Bien que ces mashups dans des représentations graphiques des tags del.icio.us  et permettent de définir des relations entre des tags mais ces relations sont déterminées d’une manière statistiques ou manuelle (intervention de l’utilisateur), en effet elles partent de fait qu’un bookmark del.icio.us est composé d’un ensemble de tags, dont la plupart ont été utilisés en même temps. Chaque tag étant relié à d’autres tags, eux-mêmes reliés à d’autres tags, ce qui permet de parcourir l’ensemble des tags en évoluant de proche en proche. Et si un tag apparais fréquemment avec d’autres tags ils sont considérés proche sémantiquement. 

L’inconvenant de cette méthode est que si un bookmark contient des posts qui sont décrits par une seul tag ou par plusieurs tags qui ne se répète pas pour plusieurs raisons (l’utilisateur s’intéresse a des sujets vraies ou il utilise plus d’une langue pour tagger ces liens) on n’obtient pas un graphe connexe mais plusieurs graphes séparée parce qu il va y avoir des tags qui ne seront pas relies aux d’autres tags même s’il y a une relation sémantique entre eux et on ne pourra pas naviguer dans l’ensemble de bookmark.

 *L’avantage d’utiliser IEML  comme une couche sémantique dans evalactisem est qu’il va permettre de :

  * regrouper les tags par rapport à des concepts,
  * repérer automatiquement les relations entre les concepts,
  * faire des opérations ensemblistes sur les agrégations,
  * calculer l’adresse sémantique de chaque tag et ainsi obtenir une position unique  dans l’espace sémantique.
  * Cette classification des bookmarks donne une idée sur le type de sujets aux quels l’utilisateur s’intéresse et donc pouvoir l’orienté vers des sujets complémentaires ou de lui proposé des networks qui partagent les mêmes intérêts.
  * la traduction des tags avec un langage pivot comme l’IEML  permet de définir les relations entre les tags même s ils sont écrits dans des langues différentes. 
==III.  Service offerts== 
Le système récupère le flux de l’API del.icio.us ensuit il le traduit dans le langage IEML  pour ajouter une couche sémantique à ce flux. La traduction est  visualisée  par des camemberts. 

Les services offerts  sont :
====1. Récupération du flux====
L’application ce connecte à l’API del.icio.us après l’authentification de l’utilisateur pour la récupération du flux.

    * L’utilisateur peut choisir le type de flux qu il souhait récupéré :
    * Les tags de bookmark,
    * Les bundles ou groupes del.icio.us,
    * Tous les posts de bookmark,
    * Les posts récents,
    * Filtrer des posts par rapport à des urls, des tags ou des dates.
====2. Traduction du flux====
La traduction est semi-automatique. S’il existe une traduction unique du tag la traduction est sauvegardée dans la base de données, et dans le cas où il existe plusieurs traductions c’est l’utilisateur qui va choisir la traduction qui lui semble pertinente parmi les traductions proposées. Sil n’existe pas de traduction sauf que l’utilisateur va choisir la traduction a partir du dictionnaire IEML  on utilisant la boussole IEML .
===3. Visualisation du flux===
L’application permet aux utilisateurs la visualisation de leurs flux (flux traduit ou flux original). 
Le flux récupéré ainsi que le flux traduit est représenté ce forme de table ou de camembert. 
==VI.   Architecture Fonctionnelle==
Dans cette partie, on détaille la structure fonctionnelle de notre système.
===VI.1 Acteurs principaux et rôle ===

 * Les administrateurs de l’outil informatique
 * Ingénieur sémantique
 * Web master
 * Les utilisateurs de del.icio.us
===VI.2 Concepts===
L’ensemble des concepts utilisés dans ce projet sont définis par une ontologie IEML .
==V. Architecture Technique ==
===V.1 Généralité===
====V.1.1 Description matériel====
Le matériel ce compose de 

 * un serveur web
 * des ordinateurs clients équipés de navigateur Firefox.
===V.1.2 Description des composants logiciels===  
Composantes logicielles du serveur :
 * Une base MySql : http://dev.mysql.com/doc/ 
 * La librairie PHP version 5 : http://www.php.net/ 

Composantes logicielles du client
 * Firefox 3.0 (moteur Gecko  1.8.1 : http://xulfr.org/wiki/Gecko )
===V.1.3 Description des liens===
Les liens utilisés sont ceux utilisés pour le WEB : HTML, XML…
===V.1.4 Choix d’implémentation===
Les technologies utilisées dans Evalactisem sont :
====V.1.4.1  Xul :====
XUL (prononcez « zoul ») est le langage d'interface utilisateur de Mozilla basé sur XML permettant de développer des applications multiplate-formes riches en fonctionnalités et pouvant tourner connectée ou non à Interne.

Avantages :

 * Langage de balisage puissant basé sur les widgets,
 * Basé sur des standards existants (XML, DOM, CSS, Javascript) : XUL est un langage basé sur le standard XML 1.0 du W3C.Les applications écrites en XUL sont aussi basées sur d'autres standards du W3C tels que HTML 4.0; les Feuilles de Style en Cascade (CSS) 1 et 2; le modèle de document objet (DOM) ; JavaScript 1.5, SVG .
 * Portabilité de la plate-forme :XUL est conçu pour être indépendant de la plateforme, rendant ainsi les applications facilement portables à tous les systèmes d'exploitation sur lesquels Mozilla tourne.
 * Séparation de l'aspect et de la logique de l'application : XUL donne une séparation claire entre la définition de l'application et la logique de programmation ("contenu" constitué de XUL, XBL, SVG et JavaScript), la présentation (« skin » constitué de CSS et d'images), et les labels spécifiques au langage (« locale » constitué de DTDs).
 * Support plusieurs technologies introduites par Mozilla qui le complète pour développer des applications web multiplate-formes (XBL, Overlays, XPCOM/XPConnect, XPInstall).
====V.1.4.2 SVG (Scalable Vector Graphics) ====
Permet d'écrire des graphiques vectoriels 2D en XML.

Avantages:
 * Langage libre de droit (aucune licence demandée),
 * Étant issu du XML, il offre la possibilité d'utiliser tous les outils XML dont les parsers, les outils de transformations et les bases de données.
 * Langage supporté par les technologies d'Internet les plus communes (HTML, GIF, JPEG, PNG, SMIL, ASP, JSP, PHP, Javascript).

 * Intégration des trois types d'objets graphiques : Formes vectorielles, images, texte
 * Possibilité de zoomer et de retailler une zone de vision.
 * Compression possible d'un fichier SVG jusqu'a 95% (en utilisant lcompression gzip).
====V.1.4.3 IEML  (Information Economy Meta Language)====
 * Langue artificielle Conçue pour être simultanément manipulable de manière optimale par les ordinateurs.

 * Un système d’adressage des concepts indépendant des langues naturelles et traductible dans toutes les langues.
 * Un adressage des concepts transversal aux ontologies (classifications, terminologies, thésaurus...).
 * Un “langage régulier” (au sens mathématique).

En plus des ces technologies récentes evalactisem utilise 
  * Php ,
  * MySql,
  * Javascript,
  * CSS,
  * Xml,
==V.2.Schéma général & description des flux==

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig8.PNG

     ====Fig 4: Schéma général & description des flux====

L’architecture de EvalActisem est une architecture Client/Serveur. 

Coté client on trouve les modules suivant :
 * Interface IHM : composée d’interface utilisateur construit avec Xul qui permet à l’utilisateur d’accéder aux différents services proposé par EvalActiSem (récupération du flux, traduction et visualisation).
 * Modules javascripts permettant la communication entre l’interface utilisateur et le serveur (la création dynamique des arbres, la gestion de traduction, la création du graphique…) en utilisant des requêtes REST (http://fr.wikipedia.org/wiki/Representational_state_transfer) ainsi que la communication enter l’interface utilisateur et l’api GoogleDocs on utilisation des requêtes Json .
Coté serveur : 
 * Module base de données : pour le stockage des flux des utilisateurs, les traductions, l’activité de l’utilisateur,
 * Modules PHP pour la récupération du flux, la création des graphes et des arbres pour la visualisation du flux.

Les flux d’information  gérés par EvalActiSem sont de trois ordres :
 # Lecture de la base de données pour générer le flux  IEML .
 # Utilisation de protocole HTTP pour récupérer le flux de l’API del.icio.us grâce à des fonctions PHP qui utilise la bibliothèque Curl.
 # Des requêtes Ajax pour la communication ente l’interface de gestion et les modules PHP et aussi pour la communication entre le serveur et l’api GoogleDocs.  
==V.2.1 Base de données pour EvalActiSem==
La base de données est modélisée suivant un schéma relationnel pour optimiser la gestion des flux. 
Ce modèle est conçu pour être le plus générique possible afin de facilement l’utiliser pour de nouvelles ontologies IEML  et d’autres système d’information.

http://evalactisem.googlecode.com/svn/trunk/documentation/images/Fig9.PNG

         ====Fig 5: Modele de base de données====

====Table ieml_onto====
Cette table est utilisée pour stocker le dictionnaire IEML.

|| *Champ*     || *Type*      || *Description*                                         ||
|| ieml_id     || int(11)     || Clef primaire auto_increment identifiant de la couche ||
|| ieml_code   || Text        || Expression IEML  exprimée en langage IEML             ||
|| ieml_desc   ||varchar(255) || Descriptif exprimé en langage naturel                 ||
|| ieml_niveau ||int(11)      || Niveau de l’expression IEML  dans l’arbre des couches ||
|| ieml_parent ||int(11)      || Identifiant de la couche parente                      ||
  
Nous proposons de limiter le descriptif de l’expression IEML  (champ ieml_desc) à 255 caractères.

====Table ieml_onto_flux====
Cette table est utilisée pour stocker le flux récupéré.

|| *Champ*           || *Type*      || *Description*                                         ||
|| onto_flux_id      || int(11)     || Clef primaire auto_increment identifiant de la connexion||
|| onto_flux_code    || varchar(255)|| Nom du Tags IEML          ||
|| onto_flux_desc    ||varchar(255) || Tags ou bundles   naturel ||
||onto_flux_niveau   ||int(11)      || 1 pour les Tags et 0 pour les Bundles ||
|| onto_flux_parents ||int(11)      || Liste de Tags parents séparer par des points virgules ||

====Table ieml_trad====
Cette table est utilisée pour stocker les traductions du Flux en expression IEML .

|| *Champ*      || *Type*      || *Description*                                         ||
|| ieml_id      || int(11)     || Identifiant de la table ieml_onto                     ||
|| onto_flux_id || int(11)     || Identifiant du flux                                   ||
|| trad_date    ||Date         || Date d’ajout de traduction                            ||

====Table ieml_uti_onto====
Cette table est utilisée  pour faire la jointure entre l’utilisateur et ces traductions. 

|| *Champ*      || *Type*      || *Description*                                         ||
|| uti_id       || int(11)     || Identifiant de l’utilisateur                          ||
|| ieml_onto_id || int(11)     || Identifiant de la table onto                          ||

====Table ieml_acti====
Cette table est utilisée pour stocker les actions du l’utilisateur à prendre en compte pour l’évaluation de l’activité 

|| *Champ*      || *Type*      || *Description*                                         ||
|| acti_id      || int(11)     || Identifiant de la table ieml_acti                     ||
|| acti_code    || text        || Chaîne de caractère exprimé avec le langage IEML   suivant la formule suivante : Source = nom de la page et identifiant de l’élément XUL a l’origine de l’activité.Destination = nom de la page et identifiant de l’élément XUL affichant le résultat de l’activité. Traduction = nom de la méthode utilisée.           ||
|| acti_desc    ||varchar(255)    || Descriptif exprimé en langag naturel               ||

====Table ieml_flux====
Cette table est utilisée pour stocker les flux IEML  produit par l’activité de l’utilisateur.

|| *Champ*     || *Type*      || *Description*                                         ||
|| flux_id     || int(11)     || Identifiant de la table ieml_flux                     ||
|| acti_id     || int(11)     || Identifiant de la table ieml_acti                     ||
|| flux_ieml   || Text        || Chaîne de caractère formaté avec le langage star sous la forme :Source = l’identifiant de l’utilisateur effectuant l’action : tu-tu-.we-b-.tu-nu-du-.[personnes,id,-]:(nombre, système d’information [nom de la table, nom du champ, -] unique)Destination = la phrase IEML correspondant au contexte sémantique de l’action Translation = la phrase IEML  correspondant au contexte sémantique du processus (navigation) ayant amené l’action. Cette expression IEML  sera construite dynamiquement par les actions de l’utilisateur.  ||
|| flux_date    ||   Date     || Date de création du flux                              ||

Il n’y a pas de taille limite pour le flux.
Chaque flux est associé à une action sur le logiciel EvalActiSem.

===V.2.2. Communication Php/MySql===
MySql permet la communication entre les fonctions PHP et la base de données. Le flux  récupéré est stocké dans la base de données dans la table del.icio.us ainsi que la traduction du flux.
===V.2.3. Communication serveur PHP/API del.icio.us===
Les classes PHP communiquent avec l’API del.icio.us on utilisant le protocole HTTP, la bibliothèque Curl de PHP permet de se connecter, de communique avec différents serveurs, grâce à de nombreux protocoles .libcurl supporte actuellement les protocoles suivants : HTTP, HTTPS, FTP, gopher, telnet, dict, file, et LDAP. libcurl supporte aussi les certificats HTTPS, les POST HTTP, PUT http [3]. 

La réponse de API del.icio.us est ce forme d’XML, la classe php le récupère, le parse et stocke le résultat dans la base de données.    
===V.2.4. Communication serveur PHP/StartParser  IEML ===
La communication entre le serveur PHP et le StartParser IEML [4] s’effectuer a l’aide des requêtes Curl. 
===V.2.5. Communication serveur  interface de gestion Xul/Serveur PHP===
L’interface de gestion communique avec le serveur PHP par des fonctions java script, une fois l’utilisateur a saisir sont login, son password et a choisi le type de visualisation qu’il souhait l’interface envoie les paramètres  de connexion a la fonction php-delicious qui se charge de la connexion avec l’API del.icio.us ainsi que de la récupération du résultat.
===V.2.6. Communication Serveur /API GoogleDocs===
Le serveur communique avec  l’api GoogleDocs par l’intermédiaire des requêtes Jason. Il envois a l’api GoogleDocs une requête en précisant le type de visualisation qu’il veut récupérer et la clé du document a récupérer. L’api répond on envoyant la réponse sous le format Jason.    
==VI. Description  des l’interfaces==
===VI.1 Interfaces logiciels===
====VI.1.1 Les objets PHP ====
Ces objets sont développés en PHP 5.
====VI.1.1.1 PhpDelicious ====
Cet objet permet de ce connecter a l’API del.icio.us et de traiter les résultats.

|| *Propriétés*                                                                        ||
|| *Nom*       || *Type*               || *Description*                                ||
|| sUsername   || Chaîne de caractères || Login  del.icio .us                          ||
|| sPassword   || Chaîne de caractères || Mot de passe del.icio.us IEML                ||
|| iCacheTime  || int                  || La durée en seconde pour mettre en cache les données récupérées                     ||
|| oXmlParder  || Objet                || Objet permettant de traiter les données del.icio.us retournées                 ||
|| bFirstchange|| Booléen              ||                                              ||
|| iLastError  || int                  ||  Type d’erreur qui prouve se produire de la connexion au serveur del.icio.us       ||


|| *Méthodes*                                                                          ||
|| *Nom*        || *IN*                          || *OUT*             ||*Description*  ||
|| PhpDelicious ||sUsername,sPassword,iCacheTime || Objet del.icio.us || Méthode de création de l’objet        ||
||HttpRequest   || sCmd                          ||                   ||Requête curl qui sera envoyée    ||
|| GetLastUpdate||         ||Date                ||Retourne la date de la dernière mise à jour            ||
||GetAllTags    ||         || Tags               ||Retourne une liste de Tags          ||
||RenameTag     ||sOld,sNew|| Tags               ||Renomme une Tag                     ||
||GetRecentPosts||sDate,iCount|| Tags            ||Retourne une liste de Posts filtrer en fonction de Tags, nombre maximum de Posts retourner est 15                             ||
||GetAllPosts   ||sTag     || Post               ||Retourne une liste de tous les Posts filtrer en fonction de Tags.                     ||
||GetDates      ||sUrl,sDescription,sNotes,aTags,sDate,bReplace                        || True ou flase   ||Ajoute un Posts              ||
||DeletePost    ||sUrl     ||                     ||Supprime un Post                   ||
||GetAllBundles ||         ||                     ||Récupère  tous les groupes de tags del.icio.us     ||
||DeleteBundle  ||sName    ||                     ||Supprime un bondles                ||
||GetAllPosts   ||sTag     || Post               ||Retourne une liste de tous les Posts filtrer en fonction de Tags.                     ||



                